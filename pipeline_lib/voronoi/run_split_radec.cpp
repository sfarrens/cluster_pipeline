/*
	Code:			run_split_radec.cpp
	Author:         Walter A. Santos Jr. (walter.augusto@gmail.com)
	Last update:	07/08/2013
	Version:		0.1
	Description: 	Code to split data points into a single box/file in radec space.
					Requires the 'boxes' file.
	Compile:		
	Usage:	see output_help() below.
*/

// Libraries
#include <fstream>
#include <iostream>
#include <string>
#include <cmath>

#include "wutils.h"

using namespace std;

const int NUM_DIMS=2; // ra, dec

void output_help(){
	cout<<"\nUsage:\n"<<flush;
	cout<<"./run_split -i <xyz_file> -b <boxes_file> (-o <file_split_n>) -n <n>\n\n"<<flush;
	cout<<"where <boxes_file> is the file containing the minmax boxes (generated by main_split)\n"<<flush;
	cout<<"<xyz_file> is the input catalog\n"<<flush;
	cout<<"with the following columns: id x y z (...)\n\n"<<flush;
	cout<<"n is the output file int number to split to (same number as listed in the main_split output).\n"<<flush;
	cout<<"<file_split_n> is the 'split' output file associated with n. It probably must be the same name\n"<<flush;
	cout<<"if you run for others <xyz_file> with the same n. If it's not given, it outputs to cout.\n\n"<<flush;
}

//main
int main(int argc, char *argv[]){

	// Checking command line
		if(argc == 1){
		output_help();
		return 0;
	}
	
	string file_in;
	string file_boxes, file_out;
	int outn = -1;
			
	for(int i=1; i<argc; i++){
		if(argv[i][0]=='-' && strlen(argv[i]) > 1){
			switch (argv[i][1]) {
				case 'h' : 
				case 'H' :
					if(strlen(argv[i]) == 2 || (strlen(argv[i]) > 2 && string(argv[i])=="-help" ) ){
						output_help();
						return 0;
					}
					break;
				case 'b' :
					if(strlen(argv[i]) == 2 || (strlen(argv[i]) > 2 && string(argv[i])=="-boxes" ) ){
						if((i+1) < argc && argv[i+1][0]!='-')
							file_boxes = argv[i+1];
						if((i+2) < argc && argv[i+2][0]!='-'){
							cout << "ERROR: Only one boxes file is accepted.\n\n";
							output_help();
							exit(-1);
						}
					}
					break;
				case 'i' :
					if(strlen(argv[i]) == 2 || (strlen(argv[i]) > 2 && string(argv[i])=="-inp" ) ){
						
						if((i+1) < argc && argv[i+i][0]!='-'){
							file_in = argv[i+1];
							
							}
						if((i+2) < argc && argv[i+2][0]!='-'){
							cout << "ERROR: Only one input file is accepted.\n\n";
							output_help();
							exit(-1);
						}
					}
					break;
				case 'o' :
					if((i+1) < argc && (strlen(argv[i]) == 2 || (strlen(argv[i]) > 2 && string(argv[i])=="-out"))){
						// checking for output file
						file_out = argv[i+1];
						if((i+2) < argc && argv[i+2][0]!='-'){
							cout << "ERROR: Only one output file is accepted.\n\n";
							output_help();
							exit(-1);
						}
					}
					break;
				case 'n' :
					if(strlen(argv[i]) == 2 ){
						if((i+1) < argc && argv[i+1][0]!='-'){
							outn = atoi(argv[i+1]);
						}
					}
					break;
					
			}
		}
	}
	
	if(file_boxes.length() == 0){
		cout << "ERROR: Input boxes file is mandatory.\n\n";
		output_help();
		exit(-1);
	}
	
	if(file_in.length() == 0){
		cout << "ERROR: Input file is mandatory.\n\n";
		output_help();
		exit(-1);
	}
	
	int _cols, num_boxes;
	vector< vector<string> > data_mx;
	wutils::read_ascii(file_boxes, data_mx, num_boxes, _cols);
	
	if(outn < 0 || outn > num_boxes-1){
		cout << "ERROR: Output file number was not found or its input value was wrong.\n\n";
		output_help();
		exit(-1);
	}
	
	//string file_out;
	//file_out = data_mx[0][outn];	
	
	vector< double > min_box;
	min_box.resize(NUM_DIMS);
	vector< double > max_box;
	max_box.resize(NUM_DIMS);
	
	// boxes file-> file_out min_x max_x min_y max_y min_z max_z
	//                 0       1     2     3     4     5     6
	for(int j=0;j<NUM_DIMS;j++){
		min_box[j] = atof(data_mx[2*j+1][outn].c_str());
		max_box[j] = atof(data_mx[2*j+2][outn].c_str());
	}
	
	//open out file
	ofstream out;
	if(file_out.length() > 0)
		out.open(file_out.c_str(), ios::out | ios::app);
	
		
	// now populate out file
	// both min and max are inclusive
	vector<double> p;
	bool inside; // aux flag
	p.resize(NUM_DIMS);
	int ncols, nrows;
	vector< vector<string> > in_mx;
	wutils::read_ascii(file_in, in_mx, nrows, ncols);
	for(int i=0; i<nrows; i++){
		inside = true;
		for(int j=0; j<NUM_DIMS; j++){
			p[j] = atof(in_mx[j+1][i].c_str());
			if (p[j] < min_box[j] || p[j] > max_box[j]){
				inside = false;
				break;
			}
		}
		if(inside){
			if(file_out.length() > 0){
				for(int k=0; k<ncols; k++)
					out << in_mx[k][i] << " ";
				//out << " " << i << "\n";
			}
			else{
				for(int k=0; k<ncols; k++)
					cout << in_mx[k][i] << " ";
				//cout << " " << i << "\n";
			}
		}
	}
	
	if(file_out.length() > 0)
		out.close();
	
	return 0;
	
}